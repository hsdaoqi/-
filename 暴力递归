//汉诺塔问题
void process(int n, string from, string to, string other) {
	if (n == 1) {
		cout << "move 1 from " << from << " to " << to<< endl;
		return;
	}
	process(n - 1, from, other, to);
	cout << "move "<<n<<" from " << from << " to " << to<< endl;
	process(n - 1, other, to, from);
}
int main() {
	process(4, "left", "right", "mid");
	return 0;
}




//栈的逆序

int f(stack<int> &st) {
	int result = st.top();
	st.pop();
	if (st.empty()) {
		return result;
	}
	else {
		int last = f(st);
		st.emplace(result);
		return last;
	}
}
void MyReverse(stack<int> &st) {
	if (st.empty()) {
		return;
	}
	int ss = f(st);
	MyReverse(st);
	st.emplace(ss);
}

int main() {
	stack<int> st;
	st.emplace(1);
	st.emplace(2);
	st.emplace(3);
	st.emplace(4);
	 MyReverse(st);
	return 0;
}




//找到所有子序列
class Solution {
    vector<vector<int>> ans;
    vector<int> tmp;
public:
   void process(vector<int>& nums,int n){
       if(n==nums.size()){
          ans.push_back(tmp);
          return;
       }
       tmp.push_back(nums[n]);
       process(nums,n+1);
       tmp.pop_back();
       process(nums,n+1);
   }
    vector<vector<int>> subsets(vector<int>& nums) {
       process(nums,0);
       reverse(ans.begin(),ans.end());
       return ans;
    }
};
