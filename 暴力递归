//汉诺塔问题
void process(int n, string from, string to, string other) {
	if (n == 1) {
		cout << "move 1 from " << from << " to " << to<< endl;
		return;
	}
	process(n - 1, from, other, to);
	cout << "move "<<n<<" from " << from << " to " << to<< endl;
	process(n - 1, other, to, from);
}
int main() {
	process(4, "left", "right", "mid");
	return 0;
}




//栈的逆序

int f(stack<int> &st) {
	int result = st.top();
	st.pop();
	if (st.empty()) {
		return result;
	}
	else {
		int last = f(st);
		st.emplace(result);
		return last;
	}
}
void MyReverse(stack<int> &st) {
	if (st.empty()) {
		return;
	}
	int ss = f(st);
	MyReverse(st);
	st.emplace(ss);
}

int main() {
	stack<int> st;
	st.emplace(1);
	st.emplace(2);
	st.emplace(3);
	st.emplace(4);
	 MyReverse(st);
	return 0;
}




//找到所有子序列
class Solution {
    vector<vector<int>> ans;
    vector<int> tmp;
public:
   void process(vector<int>& nums,int n){
       if(n==nums.size()){
          ans.push_back(tmp);
          return;
       }
       tmp.push_back(nums[n]);
       process(nums,n+1);
       tmp.pop_back();
       process(nums,n+1);
   }
    vector<vector<int>> subsets(vector<int>& nums) {
       process(nums,0);
       reverse(ans.begin(),ans.end());
       return ans;
    }
};







//找到所有全排列
void process(vector<int> ans, int index,vector<vector<int>> &res) {
	if (ans.size() == index) {
		res.push_back(ans);
		return;
	}
	for (int i = index;i < ans.size();i++) {
		swap(ans[index], ans[i]);
		process(ans, index + 1, res);
		swap(ans[index], ans[i]);
	}
}

int main() {
	vector<int> ans;
	ans.push_back(1);
	ans.push_back(2);
	ans.push_back(3);
	ans.push_back(4);
	vector<vector<int>> res;
	process(ans, 0, res);
	for (int i = 0;i < res.size();i++) {
		for (int j = 0;j < res[i].size();j++) {
			cout << res[i][j] << " ";
		}
		cout << endl;
	}
}
